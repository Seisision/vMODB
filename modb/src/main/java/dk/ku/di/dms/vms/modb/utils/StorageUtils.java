package dk.ku.di.dms.vms.modb.utils;

import dk.ku.di.dms.vms.modb.common.memory.MemoryUtils;
import dk.ku.di.dms.vms.modb.common.utils.ConfigUtils;
import dk.ku.di.dms.vms.modb.definition.Schema;
import dk.ku.di.dms.vms.modb.definition.key.IKey;
import dk.ku.di.dms.vms.modb.index.interfaces.ReadWriteIndex;
import dk.ku.di.dms.vms.modb.index.non_unique.NonUniqueHashBufferIndex;
import dk.ku.di.dms.vms.modb.index.non_unique.NonUniqueHashMapIndex;
import dk.ku.di.dms.vms.modb.index.unique.UniqueHashBufferIndex;
import dk.ku.di.dms.vms.modb.index.unique.UniqueHashChainingBufferIndex;
import dk.ku.di.dms.vms.modb.index.unique.UniqueHashMapIndex;
import dk.ku.di.dms.vms.modb.storage.record.AppendOnlyBuffer;
import dk.ku.di.dms.vms.modb.storage.record.AppendOnlyBufferOld;
import dk.ku.di.dms.vms.modb.storage.record.OrderedRecordBuffer;
import dk.ku.di.dms.vms.modb.storage.record.RecordBufferContext;
import dk.ku.di.dms.vms.modb.transaction.multiversion.IntegerPrimaryKeyGenerator;
import dk.ku.di.dms.vms.modb.transaction.multiversion.index.PrimaryIndex;

import java.io.File;
import java.io.IOException;
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.nio.channels.FileChannel;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;

import static java.lang.System.Logger.Level.DEBUG;

public class StorageUtils {

    protected static final System.Logger LOGGER = System.getLogger(StorageUtils.class.getName());

    private static final boolean SEC_IDX_IN_MEMORY_STORAGE = true;

    public static ReadWriteIndex<IKey> createUniqueIndex(Schema schema, int[] columnsIndex, String indexName){
        if(SEC_IDX_IN_MEMORY_STORAGE){
            return new UniqueHashMapIndex(schema, columnsIndex);
        }
        RecordBufferContext recordBufferContext = StorageUtils.loadRecordBuffer(10, schema.getRecordSize(), indexName, true);
        return new UniqueHashBufferIndex(recordBufferContext, schema, columnsIndex, 10);
    }

    public static ReadWriteIndex<IKey> createNonUniqueIndex(Schema schema, int[] columnsIndex, String indexName){
        if(SEC_IDX_IN_MEMORY_STORAGE){
            return new NonUniqueHashMapIndex(schema, columnsIndex);
        } else {
            OrderedRecordBuffer[] buffers = loadOrderedBuffers(MemoryUtils.DEFAULT_NUM_BUCKETS, MemoryUtils.DEFAULT_PAGE_SIZE, indexName);
            return new NonUniqueHashBufferIndex(buffers, schema, columnsIndex);
        }
    }

    private static OrderedRecordBuffer[] loadOrderedBuffers(int numBuckets, int bucketSize, String fileName){
        long sizeInBytes = (long) numBuckets * bucketSize;
        MemorySegment segment;
        try {
            segment = StorageUtils.mapFileIntoMemorySegment(sizeInBytes, fileName, true);
        } catch (Exception e){
            e.printStackTrace(System.err);
            try (Arena arena = Arena.ofShared()) {
                segment = arena.allocate(sizeInBytes);
            }
        }
        long address = segment.address();
        OrderedRecordBuffer[] buffers = new OrderedRecordBuffer[numBuckets];
        for(int i = 0; i < numBuckets; i++){
            buffers[i] = StorageUtils.loadOrderedRecordBuffer(address, bucketSize);
            address = address + bucketSize;
        }
        return buffers;
    }

    public static PrimaryIndex createPrimaryIndex(String tableName, Schema schema, boolean isCheckpointing, boolean isTruncating, boolean isChaining, int maxRecords) {
        if(isCheckpointing){
            // map this to a file, so whenever a batch commit event arrives, it can trigger checkpointing the entire file
            RecordBufferContext recordBufferContext = StorageUtils.loadRecordBuffer(maxRecords, schema.getRecordSizeWithHeader(), tableName, isTruncating);

            UniqueHashBufferIndex pkIndex;
            if(isChaining){
                pkIndex = new UniqueHashChainingBufferIndex(recordBufferContext, schema, schema.getPrimaryKeyColumns(), maxRecords);
            } else {
                pkIndex = new UniqueHashBufferIndex(recordBufferContext, schema, schema.getPrimaryKeyColumns(), maxRecords);
            }

            if(schema.isPrimaryKeyAutoGenerated()) {
                return PrimaryIndex.build(pkIndex, new IntegerPrimaryKeyGenerator());
            } else {
                return PrimaryIndex.build(pkIndex);
            }
        } else {
            if(schema.isPrimaryKeyAutoGenerated()){
                return PrimaryIndex.build(new UniqueHashMapIndex(schema, schema.getPrimaryKeyColumns()), new IntegerPrimaryKeyGenerator());
            }
            return PrimaryIndex.build(new UniqueHashMapIndex(schema, schema.getPrimaryKeyColumns()));
        }
    }

    public static OrderedRecordBuffer loadOrderedRecordBuffer(long address, int size){
        AppendOnlyBufferOld appendOnlyBuffer = new AppendOnlyBufferOld(address, size);
        return new OrderedRecordBuffer(appendOnlyBuffer);
    }

    /**
     * Must consider the header in the record size
     */
    public static RecordBufferContext loadRecordBuffer(int maxNumberOfRecords, int recordSize, String fileName, boolean truncate){
        long sizeInBytes = (long) maxNumberOfRecords * recordSize;
        MemorySegment segment = mapFileIntoMemorySegment(sizeInBytes, fileName, truncate);
        return RecordBufferContext.build(segment, fileName);
    }

    public static AppendOnlyBuffer loadAppendOnlyBuffer(int maxNumberOfRecords, int recordSize, String fileName, boolean truncate){
        long sizeInBytes = (long) maxNumberOfRecords * recordSize;
        MemorySegment segment = mapFileIntoMemorySegment(sizeInBytes, fileName, truncate);
        return new AppendOnlyBuffer(segment, fileName);
    }

    public static AppendOnlyBuffer loadAppendOnlyBufferUnknownSize(String fileName){
        MemorySegment segment = mapFileIntoMemorySegment(fileName);
        return new AppendOnlyBuffer(segment, fileName);
    }

    private static MemorySegment mapFileIntoMemorySegment(String fileName) {
        File file = buildFile(fileName);
        try {
            StandardOpenOption[] options = buildFileOpenOptions(false);
            FileChannel fc = FileChannel.open(Path.of(file.toURI()), options);
            LOGGER.log(DEBUG, "Attempt to open file in directory completed successfully: "+file.getAbsolutePath());
            return mapFileChannelIntoMemorySegment(fc, file.length());// also works: fc.size()
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static MemorySegment mapFileIntoMemorySegment(long bytes, String fileName, boolean truncate) {
        File file = buildFile(fileName);
        try {
            StandardOpenOption[] options = buildFileOpenOptions(truncate);
            FileChannel fc = FileChannel.open(Path.of(file.toURI()), options);
            LOGGER.log(DEBUG, "Attempt to open file in directory completed successfully: "+file.getAbsolutePath());
            return mapFileChannelIntoMemorySegment(fc, bytes);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static String getBasePath(){
        String userHome = ConfigUtils.getUserHome();
        String basePath;
        if(ConfigUtils.isWindows()){
            basePath = userHome + "\\vms\\";
        } else {
            basePath = userHome + "/vms/";
        }
        return basePath;
    }

    public static File buildFile(String fileName) {
        String filePath = getBasePath() + fileName + ".data";
        File file = new File(filePath);
        LOGGER.log(DEBUG, "Attempt to create new file in directory: "+filePath);
        if(file.getParentFile().mkdirs()){
            LOGGER.log(DEBUG, "Parent directory ("+file.getParentFile()+") required being created.");
        } else {
            LOGGER.log(DEBUG, "Parent directory ("+file.getParentFile()+") did not need being created.");
        }
        return file;
    }

    private static MemorySegment mapFileChannelIntoMemorySegment(FileChannel fc, long bytes) throws IOException {
        return fc.map(FileChannel.MapMode.READ_WRITE, 0, bytes, Arena.global());
    }

    private static StandardOpenOption[] buildFileOpenOptions(boolean truncate) {
        StandardOpenOption[] options;
        if(truncate){
            options = new StandardOpenOption[]{
                    StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING,
                    StandardOpenOption.SPARSE,
                    StandardOpenOption.READ,
                    StandardOpenOption.WRITE
            };
        } else {
            options = new StandardOpenOption[]{
                    StandardOpenOption.CREATE,
                    StandardOpenOption.SPARSE,
                    StandardOpenOption.READ,
                    StandardOpenOption.WRITE
            };
        }
        return options;
    }

}
