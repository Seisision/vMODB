package dk.ku.di.dms.vms.sdk.embed;

import dk.ku.di.dms.vms.modb.common.exceptions.UnsupportedConstraint;
import dk.ku.di.dms.vms.modb.common.interfaces.IEntity;
import dk.ku.di.dms.vms.modb.common.meta.ConstraintEnum;
import dk.ku.di.dms.vms.modb.common.meta.ConstraintReference;
import dk.ku.di.dms.vms.modb.store.meta.Schema;
import dk.ku.di.dms.vms.sdk.core.metadata.ForeignKeyReference;
import dk.ku.di.dms.vms.sdk.core.metadata.IVmsMetadataLoader;
import dk.ku.di.dms.vms.sdk.core.metadata.VmsMetadata;
import dk.ku.di.dms.vms.sdk.core.metadata.VmsMetadataLoader;
import dk.ku.di.dms.vms.sdk.embed.api.RepositoryFacade;
import dk.ku.di.dms.vms.modb.catalog.Catalog;
import dk.ku.di.dms.vms.modb.common.meta.DataType;
import dk.ku.di.dms.vms.sdk.core.annotations.*;
import dk.ku.di.dms.vms.modb.query.analyzer.Analyzer;
import dk.ku.di.dms.vms.modb.query.planner.Planner;
import dk.ku.di.dms.vms.modb.store.common.CompositeKey;
import dk.ku.di.dms.vms.modb.store.common.IKey;
import dk.ku.di.dms.vms.modb.store.common.SimpleKey;
import dk.ku.di.dms.vms.modb.store.index.UniqueHashIndex;
import dk.ku.di.dms.vms.modb.store.index.IIndexKey;
import dk.ku.di.dms.vms.modb.store.table.HashIndexedTable;
import dk.ku.di.dms.vms.modb.store.table.Table;
import dk.ku.di.dms.vms.sdk.core.metadata.exception.QueueMappingException;
import dk.ku.di.dms.vms.sdk.core.metadata.exception.NotAcceptableTypeException;
import dk.ku.di.dms.vms.sdk.core.metadata.exception.NoPrimaryKeyFoundException;
import dk.ku.di.dms.vms.sdk.core.operational.VmsTransactionSignature;
import org.reflections.Configuration;
import org.reflections.Reflections;

import org.reflections.scanners.*;
import org.reflections.util.ClasspathHelper;
import org.reflections.util.ConfigurationBuilder;

import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.util.*;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.persistence.*;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Null;
import javax.validation.constraints.Positive;
import javax.validation.constraints.PositiveOrZero;

public class EmbedVmsMetadataLoader implements IVmsMetadataLoader {

    private static final Logger logger = LoggerFactory.getLogger(EmbedVmsMetadataLoader.class);

    public VmsMetadataEmbed load(String forPackage) throws
            ClassNotFoundException, InvocationTargetException,
            InstantiationException, IllegalAccessException,
            QueueMappingException, NoPrimaryKeyFoundException,
            NotAcceptableTypeException, UnsupportedConstraint {

        final VmsMetadataEmbed vmsMetadata = new VmsMetadataEmbed();

        if(forPackage == null) {
            forPackage = "dk.ku.di.dms.vms";
        }
        // 1. create the data operations
        // 2. build the input to data operation and to output
        // it is necessary to analyze the code looking for @Transaction annotation
        // final Reflections reflections = new Reflections("dk.di.ku.dms.vms");

        Configuration reflectionsConfig = new ConfigurationBuilder()
                .setUrls(ClasspathHelper.forPackage(forPackage))
                .setScanners(
                        Scanners.SubTypes,
                        Scanners.TypesAnnotated,
                        Scanners.MethodsAnnotated,
                        Scanners.FieldsAnnotated
                );

        Reflections reflections = new Reflections(reflectionsConfig);

        /*
         * Building catalog
         */

        // DatabaseMetadata databaseMetadata
        final Catalog catalog = vmsMetadata.getCatalog();

        // get all fields annotated with column
        Set<Field> allEntityFields = reflections.get(
                Scanners.FieldsAnnotated.with( Column.class )// .add(FieldsAnnotated.with(Id.class))
                .as(Field.class, reflectionsConfig.getClassLoaders())
        );

        // group by class
        Map<Class<?>,List<Field>> columnMap = allEntityFields.stream()
                .collect( Collectors.groupingBy( Field::getDeclaringClass,
                Collectors.toList()) );

        // get all fields annotated with column
        Set<Field> allPrimaryKeyFields = reflections.get(
                Scanners.FieldsAnnotated.with( Id.class )
                        .as(Field.class, reflectionsConfig.getClassLoaders())
        );

        // group by entity type
        Map<Class<?>,List<Field>> pkMap = allPrimaryKeyFields.stream()
                .collect( Collectors.groupingBy( Field::getDeclaringClass,
                        Collectors.toList()) );

        // get all foreign keys
        Set<Field> allAssociationFields = reflections.get(
                Scanners.FieldsAnnotated.with(VmsForeignKey.class)
                        .as(Field.class, reflectionsConfig.getClassLoaders())
        );

        // group by entity type
        Map<Class<?>,List<Field>> associationMap = allAssociationFields.stream()
                .collect( Collectors.groupingBy( Field::getDeclaringClass,
                        Collectors.toList()) );

        // table name and respective not parsed foreign keys
        Map<String, NotParsedForeignKeyReference[]> foreignKeysPerEntity = new HashMap<>();

        // build schema of each table
        // we build the schema in order to look up the fields and define the pk hash index
        for(final Map.Entry<Class<?>, List<Field>> entry : pkMap.entrySet()){

            Class<? extends IEntity<?>> tableClass = (Class<? extends IEntity<?>>) entry.getKey();
            List<Field> pkFields = entry.getValue();

            if(pkFields == null || pkFields.size() == 0){
                throw new NoPrimaryKeyFoundException("Table class "+tableClass.getCanonicalName()+" does not have a primary key.");
            }
            int totalNumberOfFields = pkFields.size();

            List<Field> foreignKeyFields = associationMap.get( tableClass );
            List<Field> columnFields = columnMap.get( tableClass );

            if(foreignKeyFields != null) {
                totalNumberOfFields += foreignKeyFields.size();
            }

            if(columnFields != null) {
                totalNumberOfFields += columnFields.size();
            }

            final String[] columnNames = new String[totalNumberOfFields];
            final DataType[] columnDataTypes = new DataType[totalNumberOfFields];

            int[] pkFieldsStr = new int[pkFields.size()];

            // iterating over pk columns
            int i = 0;
            for(final Field field : pkFields){
                Class<?> attributeType = field.getType();
                columnDataTypes[i] = getColumnDataTypeFromAttributeType(attributeType);
                pkFieldsStr[i] = i;
                columnNames[i] = field.getName();
                i++;
            }

            NotParsedForeignKeyReference[] foreignKeyReferences = null;
            if(foreignKeyFields != null) {
                foreignKeyReferences = new NotParsedForeignKeyReference[foreignKeyFields.size()];
                int j = 0;
                // iterating over association columns
                for (final Field field : foreignKeyFields) {

                    Class<?> attributeType = field.getType();
                    columnDataTypes[i] = getColumnDataTypeFromAttributeType(attributeType);
                    columnNames[i] = field.getName();
                    i++;

                    VmsForeignKey fkAnnotation = (VmsForeignKey) Arrays.stream(field.getAnnotations())
                            .filter(p -> p.annotationType() == VmsForeignKey.class).findFirst().get();

                    // later we parse into a Vms Table and check whether the types match
                    foreignKeyReferences[j] = new NotParsedForeignKeyReference(fkAnnotation.table(), fkAnnotation.column());
                    j++;
                }

            }

            // non-foreign key column constraints are inherent to the table, not referring to other tables
            ConstraintReference[] constraints = getConstraintReferences(columnFields, columnNames, columnDataTypes, i);

            Schema schema = new Schema(columnNames, columnDataTypes, pkFieldsStr, constraints);

            createVmsTableAndRespectiveIndexes(catalog, foreignKeysPerEntity, vmsMetadata, tableClass, foreignKeyReferences, schema);

        }

        parseForeignKeyReferences(catalog, foreignKeysPerEntity, vmsMetadata);

        // TODO finish --


        /* TODO look at this. we should provide this implementation
        SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
        SLF4J: Defaulting to no-operation (NOP) logger implementation
        SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
         */

        mapTransactionInputOutput(vmsMetadata, reflections);

        return vmsMetadata;

    }

    private ConstraintReference[] getConstraintReferences(List<Field> columnFields, String[] columnNames, DataType[] columnDataTypes, int columnPosition) throws NotAcceptableTypeException, UnsupportedConstraint {
        if(columnFields != null) {

            ConstraintReference[] constraints = null;

            // iterating over non-pk and non-fk columns;
            for (final Field field : columnFields) {

                Class<?> attributeType = field.getType();
                columnDataTypes[columnPosition] = getColumnDataTypeFromAttributeType(attributeType);

                // get constraints ought to be applied to this column, e.g., non-negative, not null, nullable
                List<Annotation> constraintAnnotations = Arrays.stream(field.getAnnotations())
                        .filter(p -> p.annotationType() == Positive.class ||
                                p.annotationType() == PositiveOrZero.class ||
                                p.annotationType() == NotNull.class ||
                                p.annotationType() == Null.class
                        ).collect(Collectors.toList());

                constraints = new ConstraintReference[constraintAnnotations.size()];
                int nC = 0;
                for (Annotation constraint : constraintAnnotations) {
                    String constraintName = constraint.annotationType().getName();
                    switch (constraintName) {
                        case "javax.validation.constraints.PositiveOrZero":
                            constraints[nC] = new ConstraintReference(ConstraintEnum.POSITIVE_OR_ZERO, columnPosition);
                            break;
                        case "javax.validation.constraints.Positive":
                            constraints[nC] = new ConstraintReference(ConstraintEnum.POSITIVE, columnPosition);
                            break;
                        case "javax.validation.constraints.Null":
                            constraints[nC] = new ConstraintReference(ConstraintEnum.NULL, columnPosition);
                            break;
                        case "javax.validation.constraints.NotNull":
                            constraints[nC] = new ConstraintReference(ConstraintEnum.NOT_NULL, columnPosition);
                            break;
                        default:
                            throw new UnsupportedConstraint("Constraint " + constraintName + " not supported.");
                    }
                    nC++;
                }

                columnNames[columnPosition] = field.getName();
                columnPosition++;
            }

            return constraints;

        }
        return null;
    }

    private void createVmsTableAndRespectiveIndexes(Catalog catalog,
                                                    Map<String, ForeignKeyReference[]> foreignKeysPerEntity,
                                                    // Map<Class<? extends IEntity<?>>, Table> mapEntityClazzToTable,
                                                    VmsMetadataEmbed vmsMetadata,
                                                    Class<? extends IEntity<?>> tableClass,
                                                    ForeignKeyReference[] foreignKeyReferences,
                                                    Schema schema) {
        Annotation[] annotations = tableClass.getAnnotations();
        for (Annotation an : annotations) {
            // the developer may need to use other annotations
            if(an instanceof VmsTable){

                // table name
                String tableName = ((VmsTable) an).name();
                HashIndexedTable table = new HashIndexedTable( tableName, schema);

                if (foreignKeyReferences != null) foreignKeysPerEntity.put( tableName, foreignKeyReferences);
                vmsMetadata.registerEntityClazzMapToTable(tableClass, table);

                // table indexes
                VmsIndex[] indexes = ((VmsTable) an).indexes();
                for( VmsIndex index : indexes ){
                    String[] columnList = index.columnList().split(",\\s|,");

                    // TODO finish
                    int[] columnPosArray = schema.buildColumnPositionArray( columnList );

                    IIndexKey logicalIndexKey;
                    IKey physicalIndexKey;
                    if(columnList.length > 1){
                        physicalIndexKey = new CompositeKey(columnPosArray);
                        int[] columnPosArrayInColumnPositionOrder = Arrays.stream(columnPosArray).sorted().toArray();
                        logicalIndexKey = new CompositeKey( columnPosArrayInColumnPositionOrder );
                    }else{
                        physicalIndexKey = new SimpleKey(columnPosArray[0]);
                        logicalIndexKey = new SimpleKey(columnPosArray[0]);
                    }

                    if(index.unique()){

                        // get column position in schema

                        UniqueHashIndex hashIndex = new UniqueHashIndex(table, columnPosArray);
                        table.addIndex( logicalIndexKey, physicalIndexKey, hashIndex );

                    } else if(index.range()) {
                        // no range indexes in JPA....
                    } else {
                        // btree...
                    }

                }

                catalog.insertTable(table);
                break; // the only important annotation is vms table, thus we can break the iteration
            }

        }
    }

    /**
     * after reading all entities, then I can parse the foreign keys to actual tables
     * the reason is that I need the references to all tables before reasoning about their associations
     * @param catalog
     * @param foreignKeysPerEntity
     * @param vmsMetadata
     */
    private void parseForeignKeyReferences(Catalog catalog,
                                           Map<String, ForeignKeyReference[]> foreignKeysPerEntity,
                                           VmsMetadataEmbed vmsMetadata) {

        for( final Map.Entry<String,ForeignKeyReference[]> entry : foreignKeysPerEntity.entrySet()){
            Table table = catalog.getTable( entry.getKey() );

            Map<Table, List<Integer>> foreignKeysGroupedByTableMap = new HashMap<>();

            // iterate and parse to table and column position
            Schema schema = table.getSchema();

            ForeignKeyReference[] notParsedForeignKeyReferences = entry.getValue();
            int size = notParsedForeignKeyReferences.length;

            for(int i = 0; i < size; i++){

                Table foreignTable = vmsMetadata.getTableByEntityClazz( notParsedForeignKeyReferences[i].entityClazz );

                int column = foreignTable.getSchema().getColumnPosition( notParsedForeignKeyReferences[i].columnName );


                if(foreignKeysGroupedByTableMap.get(foreignTable) == null){
                    List<Integer> fkList = new ArrayList<>();
                    fkList.add(column);
                    foreignKeysGroupedByTableMap.put(foreignTable, fkList);
                } else {
                    // add in order
                    Iterator<Integer> iterator = foreignKeysGroupedByTableMap.get(foreignTable).iterator();
                    int pos = 0;
                    while(iterator.hasNext() && column > iterator.next()){
                        pos++;
                    }
                    foreignKeysGroupedByTableMap.get(foreignTable).add( pos, column );
                }

            }

            Map<Table, int[]> finalMap = new HashMap<>(foreignKeysGroupedByTableMap.size());
            int[] columns;
            // now store as ordered array in the schema
            for( Map.Entry<Table, List<Integer>> entry2 : foreignKeysGroupedByTableMap.entrySet()){
                columns = new int[entry2.getValue().size()];
                for(int j = 0; j < entry2.getValue().size(); j++) {
                    columns[j] = entry2.getValue().get(j);
                }
                finalMap.put(entry2.getKey(),columns);
            }

            schema.addForeignKeyConstraints( finalMap );

        }
    }





}
