package dk.ku.di.dms.vms.coordinator.server.leader;

import com.google.gson.Gson;
import dk.ku.di.dms.vms.coordinator.metadata.ServerIdentifier;
import dk.ku.di.dms.vms.coordinator.metadata.VmsIdentifier;
import dk.ku.di.dms.vms.coordinator.server.schema.Heartbeat;
import dk.ku.di.dms.vms.coordinator.server.schema.external.TransactionInput;
import dk.ku.di.dms.vms.coordinator.server.schema.internal.Issue;
import dk.ku.di.dms.vms.web_common.runnable.StoppableRunnable;

import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.ReentrantLock;

import static dk.ku.di.dms.vms.coordinator.server.Constants.*;
import static dk.ku.di.dms.vms.coordinator.server.schema.internal.Issue.Category.CHANNEL_NOT_REGISTERED;
import static java.net.StandardSocketOptions.SO_KEEPALIVE;
import static java.net.StandardSocketOptions.TCP_NODELAY;

public class Leader extends StoppableRunnable {

    private final AtomicInteger state;
    private static final int NEW                = 0;
    private static final int COMMITTING         = 1; //
    private static final int ABORTING           = 2; //
    private static final int STOPPED            = 3; //

    // a slack must be considered due to network overhead
    // e.g., by the time the timeout is reached, the time
    // taken to build the payload + sending the request over
    // the network may force the followers to initiate an
    // election. the slack is a conservative way to avoid
    // this from occurring, initiating a heartbeat sending
    // before the timeout is reached
    private int heartbeatSlack = 1000;

    // the batch window
    private long batchWindow = 60000; // a minute

    // timeout to keep track when to send heartbeats to followers
    private long heartbeatTimeout = 20000;

    // this server socket
    private AsynchronousServerSocketChannel serverSocket;

    // group for channels
    private AsynchronousChannelGroup group;

    // general tasks, like sending info to VMSs and other servers
    private ExecutorService taskExecutor;

    // even though we can start with a known number of servers, their payload may have changed after a crash
    private Map<Integer, ServerIdentifier> servers;

    private Map<Integer, VmsIdentifier> VMSs;

    private Map<Integer, RemoteConnectionMetadata> channelMetadataMap;

    // list of connected nodes that require identification
    // the identification comes after the first message received
    private Map<Integer, AsynchronousSocketChannel> unknownNodeMap;

    // the identification of this server
    private ServerIdentifier me;

    // can be == me
    private AtomicReference<ServerIdentifier> leader;

    // to encapsulate operations in the memory-mapped file
    // private MetadataAPI metadataAPI;

    // private Metadata metadata;

    // internal events generated by other threads, such as writers, e.g., channel closed, unreachable node, etc
    private Queue<Issue> issueQueue;

    // transaction requests coming from the http event loop
    private LinkedBlockingQueue<byte[]> transactionRequestsToParseQueue;

    private Gson gson;

    private BlockingQueue<ByteBuffer> byteBufferQueue;

    // then another thread must take these entries and build the events
    private Queue<TransactionInput> parsedTransactionRequests;

    // https://stackoverflow.com/questions/409932/java-timer-vs-executorservice
    // private ScheduledExecutorService scheduledBatchExecutor = Executors.newSingleThreadScheduledExecutor();

    // the heartbeat sending from the coordinator
    // private ScheduledExecutorService scheduledLeaderElectionExecutor = Executors.newSingleThreadScheduledExecutor();

    public Leader() {
        super();
        this.state = new AtomicInteger(NEW);
        this.gson = new Gson();
    }

    /**
     * Reuses the thread from the socket thread pool, instead of assigning a specific thread
     * Removes thread context switching costs.
     * This thread should not block.
     * The idea is to decode the message and deliver back to main loop as soon as possible
     */
    private class ReadCompletionHandler implements CompletionHandler<Integer, RemoteConnectionMetadata> {

        // TODO is it an (input) event, a heartbeat, an abort, a commit response?

        @Override
        public void completed(Integer result, RemoteConnectionMetadata attachment) {

            // TODO decode message


            attachment.buffer.clear();

            // need to read here again... how to get my channel? maybe the attachment should be the inet address so can retrieve safely from map?

            // attachment must include the channel and bytebuffer

            attachment.channel.read( attachment.buffer, attachment, this );
        }

        @Override
        public void failed(Throwable exc, RemoteConnectionMetadata attachment) {
            attachment.buffer.clear();
        }

    }

    private record RemoteConnectionMetadata(
         ByteBuffer buffer,
         AsynchronousSocketChannel channel,
         ReentrantLock writeLock) // reads are performed via single-thread anyway by design (completionhandler), but writes must be serialized to avoid concurrency errors
    {}

    /**
     * This is where I define whether the connection must be kept alive
     * Depending on the nature of the request
     * https://www.baeldung.com/java-nio2-async-socket-channel
     */
    private class AcceptCompletionHandler implements CompletionHandler<AsynchronousSocketChannel, Void> {

        @Override
        public void completed(AsynchronousSocketChannel channel, Void void_) {

            ByteBuffer buffer = null;

            try {

                // do I need this check?
//                if ((channel != null) && (channel.isOpen())) {
//
//                }

                channel.setOption(TCP_NODELAY, true); // true disable the nagle's algorithm. not useful to have coalescence of messages in election'
                channel.setOption(SO_KEEPALIVE, true); // better to keep alive now, independently if that is a VMS or follower

                // right now I cannot discern whether it is a VMS or follower. perhaps I can keep alive channels from leader election?
                //

                // do we have enough bytebuffers?
                if(byteBufferQueue.isEmpty()){
                    buffer = ByteBuffer.allocateDirect(1024);
                } else {
                    buffer = byteBufferQueue.remove();
                }

                // unknownNodeMap.put( channel.getRemoteAddress().hashCode(), channel );

                RemoteConnectionMetadata attachment = new RemoteConnectionMetadata( buffer, channel, new ReentrantLock() );

                channelMetadataMap.put( channel.getRemoteAddress().hashCode(), attachment );

                // create a read handler for this connection
                // attach buffer, so it can be read upon completion
                channel.read( buffer, attachment, new ReadCompletionHandler() );

            } catch(Exception e){
                // return buffer to queue
                if(channel != null && !channel.isOpen() && buffer != null){
                    byteBufferQueue.add(buffer);
                }
            } finally {
                // continue listening
                if (serverSocket.isOpen()){
                    serverSocket.accept(null, this);
                }
            }

        }

        @Override
        public void failed(Throwable exc, Void attachment) {
            if (serverSocket.isOpen()){
                serverSocket.accept(null, this);
            }
        }

    }

    private class BatchHandler implements Runnable {

        // constructor: all metadata

        @Override
        public void run() {

            // group
//            try {
//                AsynchronousChannelGroup group = AsynchronousChannelGroup.withThreadPool( taskExecutor );
//            } catch (IOException ignored) {}

            // close offset

            // get all vms that participated in the last batch

            // send commit info

            // wait for all acks given a timestamp

//            ScheduledFuture<?> schedulerHandler = scheduledBatchExecutor.schedule(new BatchHandler(), 30, TimeUnit.SECONDS );

        }

    }

    /**
     * This method contains the main loop that contains the main functions of a leader
     * (a) Heartbeat sending to avoid followers to initiate a leader election. That can still happen due to network latency.
     *  What happens if two nodes declare themselves as leaders? We need some way to let it know
     * (b) Commit/Abort management
     * (c) Processing of transaction requests
     * designing leader mode first
     * TODO maybe design follower mode in another class to avoid convoluted code
     */
    @Override
    public void run() {

        // ServerSocketChannel.open().register()

        // the batch handler must synchronize with the heartbeat??? heartbeat is only for followers? heartbeat also from vmss

        long lastBatchTimestamp = System.currentTimeMillis();
        long lastHeartbeat = lastBatchTimestamp;

        long elapsed;

        // TODO do I need this variable?
        // int state_ = state.get();

        // send heartbeat to all VMSs too.... ?
        sendHeartbeats();

        // going for a different socket to allow for heterogeneous ways for a client to connect with the servers e.g., http.
        // it is also good to better separate resources, so VMSs and followers do not share resources with external clients

        // setup asynchronous listener for new connections
        serverSocket.accept( null, new AcceptCompletionHandler());

        Future<?> readTaskFuture = CompletableFuture.completedFuture(null);
        TransactionRequestParsingTask parsingTask = new TransactionRequestParsingTask();

        while(!isStopped()){

            // should read in a proportion that matches the batch and heartbeat window, otherwise
            // how long does it take to process a batch of input transactions?
            // instead of trying to match the rate of processing, perhaps we can create read tasks
            if (readTaskFuture.isDone() && transactionRequestsToParseQueue.size() > 0) {
                readTaskFuture = taskExecutor.submit( parsingTask );
            }

            // what about the read?
            // reads and writes to the same asynchronous socket require coordination
            // concurrent support, but maximum one read and one write at time

            long now = System.currentTimeMillis();

            elapsed = now - lastHeartbeat;

            if ( elapsed >= heartbeatTimeout - heartbeatSlack ){
                // send heartbeat to all followers
                sendHeartbeats();
                lastHeartbeat = now + heartbeatSlack;
            }

            // is batch time?
            if( now - lastBatchTimestamp >= batchWindow ){

                // should keep track which events must be included in the batch, remember there must be concurrent threads reading new transactions

                lastBatchTimestamp = now;
            }

            logger.info("I am "+me.host+":"+me.port);
        }

    }

    /**
     * Given a list of known followers, send to each a heartbeat
     * Heartbeats must have precedence over other writes, since they
     * avoid the overhead of starting a new election process in remote nodes
     * and generating new messages over the network.
     *
     * I can implement later a priority-based scheduling of writes.... maybe some Java DT can help?
     */
    private void sendHeartbeats() {
        logger.info("Sending vote requests. I am "+ me.host+":"+me.port);
        for(ServerIdentifier server : servers.values()){
            RemoteConnectionMetadata connectionMetadata = channelMetadataMap.get( server.hashCode() );
            AsynchronousSocketChannel channel = connectionMetadata.channel;
            if(channel != null) {


                taskExecutor.submit( new WriterManager(HEARTBEAT, me) );

            } else {

                issueQueue.add( new Issue( CHANNEL_NOT_REGISTERED, server ) );

            }
        }
    }

    /**
     * This task is not checking the correctness of the payload!
     */
    private class TransactionRequestParsingTask implements Runnable {

        @Override
        public void run() {

            // the payload received in bytes is json format

            // must also check whether the event has correct format. leave it for later, just assume it is correct
            Collection<byte[]> drainedElements = new ArrayList<>( transactionRequestsToParseQueue.size() + 10 ); // + delta (10)
            if( transactionRequestsToParseQueue.drainTo(drainedElements) > 0 ) {
                // do not send another until the last has been completed, so we can better adjust the rate of parsing
                for (byte[] drainedElement : drainedElements) {
                    String json = new String(drainedElement);
                    TransactionInput transactionInput = gson.fromJson(json, TransactionInput.class);
                    parsedTransactionRequests.add(transactionInput);
                }

            }

        }

    }

    private record WriteRequest (
            byte type,
            AsynchronousSocketChannel channel
    )
    {}

    // write request attachment
    private record WriteRequestAttachment(
        AsynchronousSocketChannel channel, // the channel where the write operation was performed
        ByteBuffer buffer // this buffer must be cleared and put back to the buffer
    ) {}

    /**
     * The attached object represents the
     */
    private class WriteCompletionHandler implements CompletionHandler<Integer, WriteRequestAttachment> {

        // TODO is it an (input) event, a heartbeat, an abort, a commit response?

        @Override
        public void completed(Integer result, WriteRequestAttachment attachment) {

            // TODO decode message


            attachment.buffer.clear();

            // need to read here again... how to get my channel? maybe the attachment should be the inet address so can retrieve safely from map?

            // attachment must include the channel and bytebuffer

            attachment.channel.read( attachment.buffer, attachment, this );
        }

        @Override
        public void failed(Throwable exc, WriteRequestAttachment attachment) {
            attachment.buffer.clear();
            byteBufferQueue.add( attachment.buffer );
        }

    }

    List<WriteRequest> writeRequests;

    /**
     * This task assumes the channels are already established
     * Cannot have two threads writing to the same channel at the same time
     * A writer manager is responsible for defining strategies, policies, safety guarantees on
     * writing concurrently to channels.
     */
    private class WriterManager implements Runnable {

        private final byte messageType;
        private final ServerIdentifier me;

        private AsynchronousSocketChannel channel;

        public WriterManager(byte messageType, ServerIdentifier me){
            this.messageType = messageType;
            this.me = me;
        }

        @Override
        public void run() {

            ByteBuffer buffer;
            try {
                buffer = byteBufferQueue.poll(1000, TimeUnit.MILLISECONDS);
            } catch (InterruptedException ignored) {
                buffer = ByteBuffer.allocateDirect(1024);
            }

            try {

                // FIXME queue the errors

//                try {
//                    //channel.w
//                } catch (InterruptedException | ExecutionException e) {
//                    // cannot connect to host
//                    //logger.info("Error connecting to host. I am "+ me.host+":"+me.port+" and the target is "+ connectTo.host+":"+ connectTo.port);
//                }

                // now send the request
                if ( messageType == HEARTBEAT ) {
                    Heartbeat.write(buffer, me);
                } else if ( messageType == EVENT ){
                    //
                } else if( messageType == COMMIT_REQUEST ){

                }

                Integer write = channel.write(ByteBuffer.wrap( buffer.array() )).get();

                // number of bytes written
                if (write == -1) {
                    logger.info("Error on write (-1). I am "+ me.host+":"+me.port+" message type is "+messageType);

                }

                logger.info("Write performed. I am "+ me.host+":"+me.port+" message type is "+messageType+" and return was "+write);

                if (channel.isOpen()) {
                    channel.close();
                }



            } catch(Exception ignored){
                logger.info("Error on write. I am "+ me.host+":"+me.port+" message type is "+messageType);

            }

        }

    }

}
