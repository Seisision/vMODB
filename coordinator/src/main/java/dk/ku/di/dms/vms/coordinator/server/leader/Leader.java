package dk.ku.di.dms.vms.coordinator.server.leader;

import dk.ku.di.dms.vms.coordinator.metadata.ServerIdentifier;
import dk.ku.di.dms.vms.coordinator.metadata.VmsIdentifier;
import dk.ku.di.dms.vms.coordinator.server.schema.Heartbeat;
import dk.ku.di.dms.vms.coordinator.server.schema.internal.Issue;
import dk.ku.di.dms.vms.web_common.runnable.StoppableRunnable;

import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.logging.Logger;

import static dk.ku.di.dms.vms.coordinator.server.Constants.*;
import static dk.ku.di.dms.vms.coordinator.server.schema.internal.Issue.Category.CHANNEL_NOT_REGISTERED;
import static java.net.StandardSocketOptions.SO_KEEPALIVE;
import static java.net.StandardSocketOptions.TCP_NODELAY;

public class Leader extends StoppableRunnable {

    private final AtomicInteger state;
    private static final int NEW                = 0;
    private static final int PENDING_LEADER     = 1; // waiting for leader definition
    private static final int LEADER             = 2; // leader
    private static final int FOLLOWER           = 3; // follower

    // a slack must be considered due to network overhead
    // e.g., by the time the timeout is reached, the time
    // taken to build the payload + sending the request over
    // the network may force the followers to initiate a
    // election. the slack is a conservative way to avoid
    // this from occurring, initiating a heartbeat sending
    // before the timeout is reached
    private int heartbeatSlack = 1000;

    // the batch window
    private long batchWindow = 60000; // a minute

    // timeout to keep track when to send heartbeats to followers
    private long heartbeatTimeout;

    private AsynchronousServerSocketChannel serverSocket;

    private AsynchronousChannelGroup group;

    // general tasks, like sending info to VMSs and other servers
    private ExecutorService taskExecutor;

    // even though we can start with a known number of servers, their payload may have changed after a crash
    private Map<Integer, ServerIdentifier> servers;

    private Map<Integer, VmsIdentifier> VMSs;

    private Map<Integer, AsynchronousSocketChannel> serverChannelMap;

    // the identification of this server
    private ServerIdentifier me;

    // can be == me
    private AtomicReference<ServerIdentifier> leader;

    // to encapsulate operations in the memory-mapped file
    // private MetadataAPI metadataAPI;

    // private Metadata metadata;

    // internal events generated by writers, e.g., channel closed, unreachable node, etc
    private Queue<Issue> issueQueue;

    private Queue<Issue> inputQueue;

    // https://stackoverflow.com/questions/409932/java-timer-vs-executorservice
    // private ScheduledExecutorService scheduledBatchExecutor = Executors.newSingleThreadScheduledExecutor();

    // the heartbeat sending from the coordinator
    // private ScheduledExecutorService scheduledLeaderElectionExecutor = Executors.newSingleThreadScheduledExecutor();

    public Leader() {
        super();
        this.state = new AtomicInteger(NEW);
    }

    /**
     * Reuses the thread from the socket thread pool, instead of assigning a specific thread
     * Removes thread context switching costs.
     * This thread should not block.
     * The idea is to decode the message and deliver back to main loop as soon as possible
     */
    private static class MessageCompletionHandler implements CompletionHandler<Integer, ByteBuffer> {

        // TODO is it an (input) event, a heartbeat, an abort, a commit response?

        @Override
        public void completed(Integer result, ByteBuffer buffer) {



            buffer.clear();
        }

        @Override
        public void failed(Throwable exc, ByteBuffer buffer) {
            buffer.clear();
        }

    }

    /**
     * This is where I define whether the connection must be kept alive
     * Depending on the nature of the request
     */
    private static class ConnectionCompletionHandler implements CompletionHandler<AsynchronousSocketChannel, Void> {

        @Override
        public void completed(AsynchronousSocketChannel channel, Void attachment) {

            try {
                channel.setOption(TCP_NODELAY, true); // true disable the nagle's algorithm. not useful to have coalescence of messages in election'
                channel.setOption(SO_KEEPALIVE, true); // better to keep alive now, independently if that is a VMS or follower




            } catch(Exception e){

            }

        }

        @Override
        public void failed(Throwable exc, Void attachment) {

        }

    }

    private static class BatchHandler implements Runnable {

        // constructor: all metadata

        @Override
        public void run() {

            // group
//            try {
//                AsynchronousChannelGroup group = AsynchronousChannelGroup.withThreadPool( taskExecutor );
//            } catch (IOException ignored) {}

            // close offset

            // get all vms that participated in the last batch

            // send commit info

            // wait for all acks given a timestamp

//            ScheduledFuture<?> schedulerHandler = scheduledBatchExecutor.schedule(new BatchHandler(), 30, TimeUnit.SECONDS );

        }

    }

    /**
     * This method contains the main loop that contains the main functions of a leader
     * (a) Heartbeat sending to avoid followers to initiate a leader election. That can still happen due to network latency.
     *  What happens if two nodes declare themselves as leaders? We need some way to let it know
     * (b) Commit management
     * (c)
     * designing leader mode first
     * TODO maybe design follower mode in another class to avoid convoluted code
     */
    @Override
    public void run() {

        // ServerSocketChannel.open().register()

        // the batch handler must synchronize with the heartbeat??? heartbeat is only for followers? heartbeat also from vmss

        long lastBatchTimestamp = System.currentTimeMillis();
        long lastHeartbeat = lastBatchTimestamp;

        long elapsed;

        // TODO do I need this variable?
        int state_ = state.get();

        // send heartbeat to all VMSs....
        sendHeartbeats();

        // going for a different socket to allow for heterogeneous ways for a client to connect with the servers e.g., http.
        // it is also good to better separate resources, so VMSs and followers do not share resources with external clients

        while(!isStopped()){

            // read

            long now = System.currentTimeMillis();

            elapsed = now - lastHeartbeat;




            if ( elapsed >= heartbeatTimeout - heartbeatSlack ){
                // send heartbeat to all followers
                sendHeartbeats();
                lastHeartbeat = now + heartbeatSlack;
            }

            // is batch time?
            if( now - lastBatchTimestamp >= batchWindow ){

                // should keep track which events must be included in the batch, remember there must be concurrent threads reading new transactions

                lastBatchTimestamp = now;
            }

            logger.info("A round has terminated. A new one is initializing. I am "+me.host+":"+me.port);
        }

    }

    private void sendHeartbeats() {
        logger.info("Sending vote requests. I am "+ me.host+":"+me.port);
        for(ServerIdentifier server : servers.values()){
            AsynchronousSocketChannel channel = serverChannelMap.get( server.hashCode() );
            if(channel != null) {
                taskExecutor.submit(new WriteTask(HEARTBEAT, me, channel, issueQueue));
            } else {
                issueQueue.add( new Issue( CHANNEL_NOT_REGISTERED, server  ) );
            }
        }
    }

    /**
     * This task assumes the channels are already established
     */
    private static class WriteTask implements Runnable {

        private final Logger logger = Logger.getLogger(this.getClass().getName());

        private final byte messageType;
        private final ServerIdentifier me;
        private AsynchronousSocketChannel channel;

        public WriteTask(byte messageType, ServerIdentifier me, AsynchronousSocketChannel channel, Queue<Issue> issueQueue){
            this.messageType = messageType;
            this.me = me;
        }

        @Override
        public void run() {

            ByteBuffer buffer = ByteBuffer.allocate(128);

            try {

                // FIXME queue the errors

//                try {
//                    //channel.w
//                } catch (InterruptedException | ExecutionException e) {
//                    // cannot connect to host
//                    //logger.info("Error connecting to host. I am "+ me.host+":"+me.port+" and the target is "+ connectTo.host+":"+ connectTo.port);
//
//                }

                // now send the request
                if ( messageType == HEARTBEAT ) {
                    Heartbeat.write(buffer, me);
                } else if ( messageType == EVENT ){
                    //
                } else if( messageType == COMMIT_REQUEST ){

                }

                Integer write = channel.write(ByteBuffer.wrap( buffer.array() )).get();

                // number of bytes written
                if (write == -1) {
                    logger.info("Error on write (-1). I am "+ me.host+":"+me.port+" message type is "+messageType);

                }

                logger.info("Write performed. I am "+ me.host+":"+me.port+" message type is "+messageType+" and return was "+write);

                if (channel.isOpen()) {
                    channel.close();
                }



            } catch(Exception ignored){
                logger.info("Error on write. I am "+ me.host+":"+me.port+" message type is "+messageType);

            }

        }

    }

}
